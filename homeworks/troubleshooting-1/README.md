# Ответы на домашнее задание к занятию "6.6. Troubleshooting"

## Задача 1

Перед выполнением задания ознакомьтесь с документацией по [администрированию MongoDB](https://docs.mongodb.com/manual/administration/).

Пользователь (разработчик) написал в канал поддержки, что у него уже 3 минуты происходит CRUD операция в MongoDB и её 
нужно прервать. 

Вы как инженер поддержки решили произвести данную операцию:
- напишите список операций, которые вы будете производить для остановки запроса пользователя

1) Нужно получить список активных операций, которые не вернули результата:

```
db.currentOp(
   {
     "active" : true,
     "numYields" : 0,
     "waitingForLock" : false
   }
)
```

2) Затем останавливаем эту операцию, передав её opid в команду `db.killOp()`


- предложите вариант решения проблемы с долгими (зависающими) запросами в MongoDB

Быстрое решение этой проблемы - ограничить максимальное время выполнения запроса, например, до 3ех минут, при помощи команды `db.collection.find().maxTimeMS(180000)`

В общем и целом, для понимания природы зависающих запросов - возможно дело в самих запросов:
Они могут быть переусложнены, некорректны (например, зациклены).

В mongo могла возникнуть проблема с индексами в таблицах или зависает сама mongo.


## Задача 2

Перед выполнением задания познакомьтесь с документацией по [Redis latency troobleshooting](https://redis.io/topics/latency).

Вы запустили инстанс Redis для использования совместно с сервисом, который использует механизм TTL. 
Причем отношение количества записанных key-value значений к количеству истёкших значений есть величина постоянная и
увеличивается пропорционально количеству реплик сервиса. 

При масштабировании сервиса до N реплик вы увидели, что:
- сначала рост отношения записанных значений к истекшим
- Redis блокирует операции записи

Как вы думаете, в чем может быть проблема?

Redis в активном режиме может не успевать удалять записи с истекшим TTL, точнее при достижении порога отношения истекших записей к новым в секунду более 25% - происходит блокировка работы Redis, пока не снизится порог истекших записей. Это необходимо для того,
чтобы избежать использования слишком большого количества памяти для ключей, срок действия которых уже истек.

 
## Задача 3

Перед выполнением задания познакомьтесь с документацией по [Common Mysql errors](https://dev.mysql.com/doc/refman/8.0/en/common-errors.html).

Вы подняли базу данных MySQL для использования в гис-системе. При росте количества записей, в таблицах базы,
пользователи начали жаловаться на ошибки вида:
```python
InterfaceError: (InterfaceError) 2013: Lost connection to MySQL server during query u'SELECT..... '
```

Как вы думаете, почему это начало происходить и как локализовать проблему? Какие пути решения данной проблемы вы можете предложить?

Согласно документации, это происходит благодаря тому что:

1) Пользователь не может получить весь запрошенный объем данных в течении определенного времени.
   
   Проблема локализуется при помощи увелечения параметра ```net_read_timeout```, по умолчанию он равен 30 секундам.

2) Пользователь не может дождаться ответа от базы данных в течении долгого времени.

   Можно увелчить параметр ```connect_timeout```, для детального изучения проблемы можно использовать ```SHOW GLOBAL STATUS LIKE 'Aborted_connects'```

3) У базы данных проблемы с подключением в сети или не хватает ресурсов или нарушена целостность базы данных

  Стоит проверить состояние сети, хватает ли базе ресурсов, если ресурсов хватает - возможно стоит изучить дамп, чтобы проверить целостность базы

  
## Задача 4

Перед выполнением задания ознакомтесь со статьей [Common PostgreSQL errors](https://www.percona.com/blog/2020/06/05/10-common-postgresql-errors/) из блога Percona.

Вы решили перевести гис-систему из задачи 3 на PostgreSQL, так как прочитали в документации, что эта СУБД работает с 
большим объемом данных лучше, чем MySQL.

После запуска пользователи начали жаловаться, что СУБД время от времени становится недоступной. В dmesg вы видите, что:

`postmaster invoked oom-killer`

Как вы думаете, что происходит? Как бы вы решили данную проблему?

Происходит недостаток оперативной памяти для PostgreSQL, Linux старается завершать ресурсоемкие процессы, чтобы не завершать работы всей системы (ядра)

Решение данной проблемы:

   1) Увеличение RAM и других ресурсов на сервере
   
   2) Сократить количество потребляемой памяти в конфигурации PostgreSQL (но это может замедлить быстродействие Postgre)

   3) Возможно стоит оптимизировать работу PostgreSQL, например, его стоит партициоинировать или оптимизировать запросы

   4) Также возможно на сервере есть вытесняющие процессы, которые "отнимают" ресурсы у Postgre
