1. Какого типа команда cd? Попробуйте объяснить, почему она именно такого типа; опишите ход своих мыслей, если считаете что она могла бы быть другого типа.

```
$ type cd
cd is a shell builtin
```

cd - встроенная команда shell. Она такого типа, потому что должна менять cwd (current working directory). Если бы cd была программой - она меняла бы cwd только своего подпроцесса, а после выполнения shell бы оставался в точке запуска. cd же меняет cwd родительского процесса shell

2. Какая альтернатива без pipe команде grep <some_string> <some_file> | wc -l? man grep поможет в ответе на этот вопрос. Ознакомьтесь с документом о других подобных некорректных вариантах использования pipe.

```grep <some_string> <some_file> -c```,  или --count (print a count of matching lines for each input file)

3. Какой процесс с PID 1 является родителем для всех процессов в вашей виртуальной машине Ubuntu 20.04?

```
$ pstree -p | head -1
systemd(1)-+-VBoxService(773)-+-{VBoxService}(775)
```

Ответ: systemd(1)

4. Как будет выглядеть команда, которая перенаправит вывод stderr ls на другую сессию терминала?

Если у сессии терминала 1 tty = /dev/pts/0, а у сессии терминала 2 tty = /dev/pts/1, то:

```
$ ls /wrong_directory 2> /dev/pts/1
```
5. Получится ли одновременно передать команде файл на stdin и вывести ее stdout в другой файл? Приведите работающий пример.

Получится, вот пример:

```cat < /tmp/example.txt 1> /tmp/example-1.txt```

6. Получится ли вывести, находясь в графическом режиме, данные из PTY в какой-либо из эмуляторов TTY? Сможете ли вы наблюдать выводимые данные?

Да, получится, вот пример команды:

```
$ echo Hi >/dev/tty1
```

Вот что наблюдал:

```
vagrant@vagrant:~$ Hi
```

7. Выполните команду bash 5>&1. К чему она приведет? Что будет, если вы выполните echo netology > /proc/$$/fd/5? Почему так происходит?

```bash 5>&1``` - создаст новый файловый дескриптор "5" и перенаправит его на stdout (1)
```/proc/$$/fd``` - содержит ссылки для дескрипторов файлов, которые были открыты собственным процессом $$.
```echo netology > /proc/$$/fd/5``` - выведет netology, т.к. мы перенаправили вывод echo в дескриптор "5", а дескриптер в stdout. 

Если не выполнять ```bash 5>&1```, произойдет ошибка, из-за отсутствия дескриптора "5"

8. Получится ли в качестве входного потока для pipe использовать только stderr команды, не потеряв при этом отображение stdout на pty? Напоминаем: по умолчанию через pipe передается только stdout команды слева от | на stdin команды справа. Это можно сделать, поменяв стандартные потоки местами через промежуточный новый дескриптор, который вы научились создавать в предыдущем вопросе.

```
$ ls /example 3>&2 2>&1 1>&3 | grep -n "file"
$ 1:ls: cannot access '/example': No such file or directory
```

```3>&2``` - дескриптор 3 перенаправили в stderr, ```2>&1``` - stderr перенаправили в stdout, ```1>&3``` - stdout перенаправили в другой дескриптор;

Ответ - получится

9. Что выведет команда cat /proc/$$/environ? Как еще можно получить аналогичный по содержанию вывод?

Выведет переменные среды, аналогичный вывод можно получить командой ```env``` или ```printenv```

10. Используя ```man```, опишите что доступно по адресам ```/proc/<PID>/cmdline```, ```/proc/<PID>/exe.```

```man proc | grep -C 10 cmdline```

/proc/[pid]/cmdline - файл, доступный только для чтения, содержит полную командную строку и аргументы, в которой запущен данный процесс (если он не является зомби процессом)

```man proc | grep -C 5 exe```

/proc/[pid]/exe - символическая ссылка на файл, который был инициатором запуска процесса

11. Узнайте, какую наиболее старшую версию набора инструкций SSE поддерживает ваш процессор с помощью ```/proc/cpuinfo```.

```grep -i sse /proc/cpuinfo```

Ответ: sse4_2

12. При открытии нового окна терминала и vagrant ssh создается новая сессия и выделяется pty. Это можно подтвердить командой tty, которая упоминалась в лекции 3.2. Однако:
```
vagrant@netology1:~$ ssh localhost 'tty'
not a tty
```

```tty``` выводит имя терминала, связанного с stdin.

```ssh localhost 'tty'```, команда выполняется не в терминале, чтобы это изменить и выполнить эту команду на localhost нужно добавить флаг ```-t```, тогда создастся псевдотерминал

13. Бывает, что есть необходимость переместить запущенный процесс из одной сессии в другую. Попробуйте сделать это, воспользовавшись reptyr. Например, так можно перенести в screen процесс, который вы запустили по ошибке в обычной SSH-сессии.

Установка: 

```
$ sudo apt-get install reptyr
```

Terminal1

```
nano example
```

Terminal2

Получаем pid и передаем его в reptyr

Настраиваем reptyr

```
nano /etc/sysctl.d/10-ptrace.conf
```

Устанавливаем значение ```kernel.yama.ptrace_scope = 0```


```
sysctl -p /etc/sysctl.d/10-ptrace.conf

$ ps -a | grep nano
```

И открываем

```
reptyr -s 1995
```

14. sudo echo string > /root/new_file не даст выполнить перенаправление под обычным пользователем, так как перенаправлением занимается процесс shell'а, который запущен без sudo под вашим пользователем. Для решения данной проблемы можно использовать конструкцию echo string | sudo tee /root/new_file. Узнайте, что делает команда tee и почему в отличие от sudo echo команда с sudo tee будет работать.

```man tee```

Команда tee читает из stdin и пишет в stdout и файлы.

В ```sudo echo string``` - sudo применяется к echo, а не к записи в файл.

```sudo tee``` - sudo применяется к tee, таким образом у tee будут права на запись в файл. Таким образом echo выполняется без sudo (обычным пользователем), а вывод stdout echo перенаправляется на stdin tee, запущенной от sudo, и она записывает данные в файл.
